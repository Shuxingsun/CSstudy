# 深入相浅出索引（下）

查询过程：

```mysql
select * from T where k between 3 and 5
```

1. 在k索引树上找到k=3的记录，取得 ID = 300； 

2. 再到ID索引树查到ID=300对应的R3； 

3. 在k索引树取下一个值k=5，取得ID=500； 

4. 再回到ID索引树查到ID=500对应的R4； 

5. 在k索引树取下一个值k=6，不满足条件，循环结束。

**回表：**回到主键索引过程。

这个查询过程读了k 索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。 

**怎样避免回表**

## 覆盖索引

**查询的值已经在K索引树上，因此可以直接提供查询结果，不需要回表**

```mysql
select ID from T where k between 3 and 5
```

**由于覆盖索引可以减少树的搜索次数，所以覆盖索引是一个常用的性能优化手段**

## 最左前缀原则

- 针对一个不频繁的创建一个索引时，有点浪费，应该怎么办
- `B+`树索引结构，可以利用索引的“最左前缀”，来定位记录

- 最左前缀指的是，匹配就行

  - 查找名字是“张三”，只需要匹配“张三”这两个字段
  - 查找名字第一个字是“张”，只需要匹配“第一个字是”张“的

- 在建立索引时，如何安排索引内字段顺序

  - **评估标准：**索引的复用能力

  - 第一原则，如果通过调整，可以少维护一个索引，那么这个顺序就是优先考虑的

    - 例如：已经有了(a,b)这个联 合索引后，一般就不需要单独在a上建立索引了。

  - 第二原则：空间。尽可能选择字段小的

    - 如果既有联合查询，又有基于a、b各自的查询。查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、 (b) 这两个索引。

    - 比如上面这个市民表的情况，name字段是比age字段 

      大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。 

## 索引下推

**针对不符合最左前缀的部分**

```mysql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

- 在`MySQL 5.6`之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。
- 这个过程`InnoDB`并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_15-51-51.png)

- `MySQL 5.6` 引入的**索引下推优化**（index condition pushdown)， 可以在索引遍历过程中，对索 引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
- `InnoDB`在(name,age)索引内部就判断了age是否等于10，对于不等于10的 记录，直接判断并跳过

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_15-52-09.png)

