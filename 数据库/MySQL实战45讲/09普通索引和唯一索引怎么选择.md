# 普通索引和唯一索引，应该怎么选择

**举例：身份证场景**

**不同索引对查询和更新的性能影响**



### 查询过程

`select id from T where k = 5;`

这个查询语句在索引树上查找的过程，先 是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认 为数据页内部通过二分法来定位记录。

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰 到第一个不满足k=5条件的记录。 

- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继 续检索。

`InnoDB`的**数据是按数据页为单位来读写的**。也就是说，当需要读一条记录的时候， 并不是将**这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存**.`InnoDB`每个数据页默认大小16KB.

### 更新过程

#### change buffer：

当需要更新一个数据页时，如果数据页在内存中就直接更新，而<u>如果这个数据页还没有在内存中</u> 的话，在不影响数据一致性的前提下，InooDB会将这些<u>更新操作缓存在change buffer</u>中，这样 就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。

将<u>change buffer中的操作应用到原数据页，得到最新结果的过程称为merge</u>。除了访问这个数据 页会触发merge外，<u>系统有后台线程会定期merge</u>。在<u>数据库正常关闭（shutdown）的过程中，也会执行merge操作。</u> 

**什么条件下使用change buffer**

- 唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用
- change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通 过参innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

#### 如果在这张表中插入新纪录(4,400),InnoDB的处理流程怎样

1. 第一种情况，记录要更新的目标页在内存中

   - 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束； 

   - 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。 

2. 目标页不在内存中

   - 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
   - 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。

将数据从**磁盘读入内存涉及随机IO的访问**，是**数据库里面成本最高**的操作之一。**change buffer 因为减少了随机磁盘访问**，所以对更新性能的提升是会很明显的



## `change buffer`使用场景

普通 索引的所有场景，使用change buffer都可以起到加速作用吗?

- 写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。业务模型常见的就是**账单类、日志类的系统。**
- 假设一个业务的更新模式是**写入之后马上会做查询**，那么即使满足了条件，将更新先记 录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说change buffer反而起到了副作用



## 索引选择和实践

这两类索引在查询能力上 是没差别的，**主要考虑的是对更新性能的影响**。所以，我建议你**尽量选择普通索引**。



## `change buffer `和`redo log`

**change buffer更新过程**

- Page 1在内存中，直接更新内存；
- Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个 信息 
- 将上述两个动作记入redo log中
- 就是**写了 两处内存，然后写了一处磁盘**（两次操作合在一起写了一次磁盘），而且还是顺序写。

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-10_17-26-15.png)



**读请求流程图：**

- 读Page 1的时候，直接从内存返回

- 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果

  ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-10_17-27-53.png)

  

**`redo log` 主要节省写磁盘的IO消耗，而 `change buffer`主要节省的则是随机读磁盘的IO消耗**

