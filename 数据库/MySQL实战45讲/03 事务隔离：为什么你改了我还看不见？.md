#  事务隔离：为什么你改了我还看不见？

## 经典例子：转账

转账包括：查询余额、做加减法、更新余额

Bug:不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次

**事务支持在引擎层实现**

`MySQL`原生`MyISAM`引擎不支持事务，进而被`InnoDB`代替。

## 隔离性与隔离级别

**ACID**（Atomicity、Consistency、Isolation、Durability，即原子性、一 致性、隔离性、持久性）

**多个事务同时执行可能出现问题：**

- 脏读
- 不可重复读
- 幻读

**事务隔离级别**

- 读未提交
  - 一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交
  - 一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读
  - 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的
- 串行化（`serializable` ）
  - 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

### 举例：

```mysql
create T(c int) engine = InnoDB;
insert into T(c) values(1);
```

**两个事务执行过程：**

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2.png)

**不同隔离级别得到不同V值**

- 若隔离级别是“读未提交”， 则V1的值就是2。这时候<u>事务B虽然还没有提交，但是结果已经被 A看到</u>了。因此，V2、V3也都是2。 

- 若隔离级别是“读提交”，则V1是1，V2的值是2。<u>事务B的更新在提交后才能被A看到</u>。所以， V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求： 事<u>务在执行期间看到的数据前后必须是一致的</u>。 

- 若隔离级别是“串行化”，<u>则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后， 事务B才可以继续执行</u>。所以从A的角度看， V1、V2值是1，V3的值是2。 

Oracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从`Oracle`迁移到`MySQL`的应用，为保证数据库隔离级别的一致，**你一定要记得将`MySQL`的隔离级别设置为“读提交”**

```mysql
-- 查看命令
show variables like 'transaction-isolation'
```

**可重复读的场景：**银行账户表

## 事务隔离的实现

**可重复读理解**

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-01_18-36-31.png)

当前值是4，但是在查询这条记录的时候，<u>不同时刻启动的事务会有不同的read-view</u>。如图中看 到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，**同一条记录在系统中可以存在多 个版本**，就是数据库的多版本并发控制（MVCC）。对于read-viewA，要得到1，就必须将当前 值依次执行图中所有的回滚操作得到。

- 回滚日志总不能一直保留吧，什么时候删除呢？

- **答案是，****在不需要的时候才删除**。 也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除

**为什么不尽量用长事务**

- 意味着**系统里面会存在很老的事务视图**。由于这些事务随时可能访问数据库里面的任何数 

  据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，**这就会导致大量占** 

  **用存储空间**

- 占用锁资源，也可能拖垮整个库

## 长事务启动方法

**启动方法**

1. 显式启动事务语句， `begin` 或 `start transaction`。配套的提交语句是`commit`，回滚语句是`rollback`。 

2. `set autocommit=0`，**这个命令会将这个线程的自动提交关掉**。意味着如果你只执行一个 select语句，这个事务就启动了，而且并不会自动提交。<u>这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</u>

**避免长事务:**`set autocommit=1`

**多一次交互：**`commit work and chain`

- 在`autocommit`为1的情况下，用`begin`显式启动的事务，如果执行`commit`则提交事务。如果执行 `commit work and chain`，则是提交事务并自动启动下一个事务，这样也省去了再次执行`begin`语 句的开销。

- 同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 

