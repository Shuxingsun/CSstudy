# 全局锁和表锁：给表加字段这么多阻碍

**数据库锁的设计初衷是为了处理并发问题**

**`MySQL`锁的分类：全局锁、表级锁、行锁**

## 全局锁

**命令：**

```mysql
Flush tables with read lock (FTWRL)
```

当你需要让整个库处于只读状态的时候，可以使用这个命 令，之后其他线程的以下语句会被阻塞:数据更新语句（数据的增删改）、数据定义语句（包括 建表、修改表结构等）和更新类事务的提交语句。

**应用场景：全库逻辑备份**——整库每个表都select出来存成文本。

在备份过程，整库属于**只读状态**

**只读状态的危险性：**

- 如果你在主库上备份，那么在备份期间都不能执行更新，**业务基本上就得停摆**
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的`binlog`，会导致`主从延迟`。 

**不加锁的问题**：

购买系统：先备份账户余额表否备份用户课程表

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_16-18-37.png)

**备份结果**：用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了 一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了

**相反的顺序：**用户买了课，账户减去一部分钱，但没有课程信息。

**不加锁，备份的库和原来的库不是一个逻辑点，视图不一致**

**拿到一致性视图——可重复读隔离级别下开启下一个事务：**

- 官方自带的逻辑备份工具是`mysqldump`。当`mysqldump`使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。
- **需要`FTWRL`的必须性**
  - 对于`MyISAM`这种不支持事务的引擎，如果备份过程中有更新，总是 只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用`FTWRL`命令，、。
- `single-transaction`只支持适用于所有表适用于事务引擎的的库。

**全库只读，为何不使用`set global readonly=true`**

- 一是，在有些系统中，`readonly`的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。修改global变量的方式影响面更大
- 二是，在异常处理机制上有差异.如果执行`FTWRL`命令之后由于客户端发生异常断开，那么 `MySQL`会自动<u>释放这个全局锁，整个库回到可以正常更新的状态</u>。而将整个库设置为 `readonly`之后，<u>如果客户端发生异常，则数据库就会一直保持`readonly`状态，这样会导致整个 库长时间处于不可写状态，风险较高。</u>

## 表级锁

### 表锁

**语法：`lock tables --read/write`**

- unlock tables主动释放锁.

- lock tables语法除了会**限制别的线程**的读写 外，也限定了**本线程**接下来的操作对象

- 对于`InnoDB`这种支持 行锁的引擎，**一般不使用lock tables命令来控制并发**，毕竟锁住整个表的影响面还是太大。



### 元数据锁（`MDL`）

- `MDL`不需要显式使用，在访问一个表的时候会被 自动加上
- 作用：保证读写正确性
- 在**`MySQL 5.5`版本中引入了`MDL`**，当对一个表做增删改查操作的时候，加`MDL`读锁；当 要对表做结构变更操作的时候，加`MDL`写锁。
  - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
  - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性

#### 坑：给小表加一个字段，导致整个库挂掉

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_16-31-43.png)

- 之后session C会被blocked，是因为session A的`MDL`读锁还没有释放，而session C需要`MDL`写 锁，因此只能被阻塞。
- 但是之后所有要在表t上新申请`MDL`读锁的请求也 会被session C阻塞
- 如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session 再请求的话，这个库的线程很快就会爆满
- 事务中的`MDL`锁，**在语句执行开始时申请，但是语句结束后并不会马上释 放，而会等到整个事务提交后再释放**

#### 解决办法：解决长事务

- 在alter table语句里面设**定等待时间**，如果在这个指定的等待时间里面能够拿到`MDL`写锁最好，**拿不到也不要阻塞后面的业务语句，先放弃**之后开发人员或者`DBA`再通过重试命令重复这个过程。

-  `MariaDB`已经合并了`AliSQ`L的这个功能，所以这两个开源分支目前都支持`DDL NOWAIT/WAITn` 

  - 语法：

    ```mysql
    ALTER TABLE tbl_name NOWAIT add column ... 
    ALTER TABLE tbl_name WAIT N add column ...
    ```

    

