# 行锁功过：怎么减少行锁对性能的影响？

- **`MySQL`行锁是在引擎层由各个引擎自己实现的,但并不是所有的引擎都支持行锁**

- `MyISAM`引擎就不支持行锁。**不支持行锁意味着并发控制只能使用表锁**.对于这种引擎的表，同 一张表上**任何时刻只能有一个更新在执行**，这就会影响到业务并发度

**`MyISAM`被`InnoDB`替代的重要原因之一**

## 二阶段锁

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_16-28-06.png)

**问题：**事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。 你可以验证一下：实**际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才 能继续执行**

**二阶段锁：在`InnoDB`事务中，行锁是在需要的时候才加上，但不是立刻释放的，而是要等到事务结束后才释放**

**事务运用：**如果你的事务中需要锁多个行，要把**最可能造成锁冲突、最可能影响并发度的锁尽量往后放**

**举例：**

> 实现一个电影票在线交易业务，顾客A要在影院B购买电影票.涉及以下操作
>
> 1. 从顾客A账户余额中扣除电影票价； 
>
> 2. 给影院B的账户余额增加这张电影票价； 
>
> 3. 记录一条交易日志。
>
> 试想如果同时有**另外一个顾客C要在影院B买票**，那么这两个事务冲突的部分就是语句2

正确的语句顺序：3、1、2



## 死锁和死锁检测

**死锁：**涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态

**例子：**

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_16-33-17.png)

事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。

**死锁对应策略：**

- 直接进入等待，直到超时。这个超时时间可以通过参数`innodb_lock_wait_timeout`来设置
  - `innodb_lock_wait_timeout`的默认值是50s，对于在线服务来说，等待时间无法接受；如果设置为`1s`,时间太多，会产生很多误伤
- 发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行
  - `innodb_deadlock_detect`的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的——消耗大量CPU资源。

**解决死锁消耗大量CPU资源问题：**

- **头疼医头**：如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉
- 控制并发度
  - 在客户端控制并发。**不可行，客户端很多**
  - 在数据库服务端或者中间件异或修改`MySQL`源码——**基本思路就是，对于相同行的更新， 在进入引擎之前排队**
- 在设计上优化——通过将一行改成逻辑上的多行来减少锁冲突
  - 还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。**将影院账户记录改成多行**

