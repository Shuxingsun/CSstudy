# 日志系统：一条SQL更新语句是如何执行的？ 

## 执行过程

更新语句执行过程和查询语句过程差不多。

连接器 ->查询缓存（更新，缓存清空） ->分析器 ->执行器

**更新过程还涉及两个日志模块**

- redo log（重做日志）
- `binlog`(归档日志)

##  redo log

**redo log 是InnoDB 引擎的日志**

### 酒店老板记账

- 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉； 

- 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算

粉板和账本结合就是`MySQL`的`WAL`技术：Write- Ahead Logging，它的关键点就是**先写日志，再写磁盘**。

**`crash-safe`:**指的是有了redo log，`InnoDB`就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失.

## `binlog`

**Server层的日志**

**`binglog`**没有`crash-safe`能力。

### **不同**

- redo log是`InnoDB`引擎特有的；`binlog`是`MySQL`的Server层实现的，所有引擎都可以使用
- redo log是物理日志，记录的是“在某个数据页上做了什么修改”；`binlog`是逻辑日志，记录的 是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
- redo log是循环写的，空间固定会用完；`binlog`是可以追加写入的。“追加写”是指`binlog`文件 写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## 执行过程

```mysql
update t set c=c+1 where id=2;
```



1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一 行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然 后再返回。 

2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据。 

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处 于**prepare**状态。然后告知执行器执行完成了，随时可以提交事务。 

4. 执行器生成这个操作的`binlog`，并把`binlog`写入磁盘。 

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成**提交（commit）状态**，更 新完成。 

## 二阶段提交

**redo log 的两个阶段的作用：保持数据库恢复出出来的状态和用日志回复出来的一样：prepare ->`binlog` ->commit**

不这样的话，可能出现的情况：

1. 先后`redo log`写`binlog`。假设在`redo` log写完，`binlog`还没有写完的时候，`MySQL`进程异 常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 **但是由于`binlog`没写完就crash了，这时候`binlog`里面就没有记录这个语句**。因此，之后备份 日志的时候，存起来的`binlog`里面就没有这条语句。 然后你会发现，如果需要用这个`binlog`来恢复临时库的话，由于这个语句的`binlog`丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同
2. 先后`binog`写`redo log`。**如果在`binlog`写完之后crash，由于redo log还没写，崩溃恢复以 后这个事务无效，所以这一行c的值是0**。但是`binlog`里面已经记录了“把c从0改成1”这个日 志。所以，在之后用`binlog`来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的 状态不一致。 