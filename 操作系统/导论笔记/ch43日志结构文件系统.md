# 日志结构文件系统

**日志文件系统的起因：**

- 内存大小不断增长。
- 随机 **I/O** 性能与顺序 **I/O** 性能之间存在巨大的差距，且不断扩大：传输带宽每年增加约 **50%** **～ ** **100%**
- 现有文件系统在许多常见工作负载上表现不佳
- 文件系统不支持 **RAID**。

 **LFS，是日志结构文件系统**

写入磁盘时，LFS 首先将所有更新（包括元数据！）缓冲在内存段中。当段已满时，它会在一次长时间的顺序传输中写入磁盘，并传输到磁盘的未使用部分



**关键问题：如何让所有写入变成顺序写入**

> 文件系统如何将所有写入转换为顺序写入？对于读取，此任务是不可能的，因为要读取的所需块可能是磁盘上的任何位置。但是，对于写入，文件系统总是有一个选择，而这正是我们希望利用的选择.



## 按顺序写入磁盘 

简单地将所有更新（例如数据块、inode 等）顺序写入磁盘的这一基本思想是 LFS 的核
 心.

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_10-59-24.png)



## 顺序而高效地写入 

针对在第一次和第二次写入之间，磁盘已经旋转。当你发出第二次写入时，它将在提交之前等待一大圈旋转。你必须向驱动器发出**大量连续写入**（或一次大写入）才能获得**良好的写入性能**

**解决方案——写入缓冲:**写入磁盘之前，LFS 会跟踪内存中的更新。收到足够数量的更新时，会立即将它们写入磁盘，从而确保有效使用磁盘

LFS 一次写入的**大块更新被称为段**（segment）

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_11-03-13.png)



## 要缓冲多少

答案当然**取决于磁盘本身**，特别是与传输速率相比定位开销有多高

**例子：**

假设要写入 *D* MB 数据。写数据块的时间 *T*write是定位时间

*T*position 的加上 *D* 的传输时间Dtran。D/Tpos

Twrite = Tpost + Dtran

有效写入速率：Reffec = D/Twrite 

....

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_11-07-25.png)



举个例子，一个磁盘的定位时间为 10ms，峰值传输速率为 100MB/s。假设我们希望有效带宽达到峰值的 90%（*F* = 0.9）。在这种情况下，*D* = 0.9×100MB/s×0.01s= 9MB。请尝试一些不同的值，看看需要缓冲多少才能接近峰值带宽，达到 95%的峰值需要多少，达到 99%呢



## 问题：查找inode

在典型的文件系统（如 FFS）甚至老 UNIX 文件系统中，查很 inode 很容易，因为它们以**数组形式**组织，并放在**磁盘的固定位置**上.

老UNIX文件系统，要查很特定的 inode，只需将 inode 号乘以 inode 的大小，然后将其加上磁盘数组的起始地址，即可计算其确切的磁盘地址

 

在新的**FFS** 中查很给定 inode 号的 inode 仅稍微复杂一些，因为 FFS 将 inode 表拆分为块并在每个柱面组中放置一组 inode。因此，必须知道每个 inode 块的大小和每个 inode 的起始地址。之后的计算类似，也很容易。

**问题：**更糟糕的是，我们**永远不会覆盖**，因此最新版本的 inode（即我们想要的那个）会不**断移动。**

## 通过间接解决方案：inode 映射 

在 inode 号和 inode 之间引入了一个间接层（level of indirection）。imap 是一个结构，它将 inode号作为输入，并生成最新版本的 inode 的磁盘地址.

LFS 将 inode 映射的块放在它写入所有其他新信息的位置旁边

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_11-13-15.png)



## 检查点区域

LFS 在磁盘上只有这样一个<u>固定的位置</u>，称为**检查点区域**——检查点区域包含指向最新的 inode 映射片段的指针（即地址），因此可以通过首先读取 CR 来很到 inode 映射片段

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_11-14-40.png)

## 从磁盘读取文件：回顾

- 必须读取的第一个磁盘数据结构是检查点区域
- 因此 LFS 读入整个 inode 映射并将其缓存在内存中
- 当给定文件的 inode 号时，LFS 只是在 imap 中查很 inode 号到inode 磁盘地址的映射，并读入最新版本的 inode
- 直接指针或间接指针或双重间接指针

## 目录如何

目录结构与传统的 UNIX 文件系统基本相同，因为目录只是（名称，inode号）**映射的集合**

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_11-16-44.png)

- inode 映射的片段包含目录文件 dir 以及新创建的文件 f 的位置信息
- inode 映射还解决了 LFS 中存在的另一个严重问题，称为**递归更新问题**



## 垃圾收集

另一个问题；它会反复将最新版本的文件

LFS 会在整个磁盘中<u>分散旧版本的文件结构</u>。我们（毫不客气地）将这些旧版本称为垃圾

**版本控制文件系统：**可以保留那些旧版本并允许用户恢复旧文件版本

**LFS 只保留文件的最新活版本：**LFS 必须定期查很文件数据，索引节点和其他结构的旧的死版本，并清理（clean）它们。清理过程是垃圾收集。

两个问题：

- 第一个是机制：LFS 如何判断段内的哪些块是活的，哪些块已经死了
- 第二个是策略：清理程序应该多久运行一次，以及应该选择清理哪些部分



## 确定块的死活

**段摘要块：**其 inode 号（它属于哪个文件）及其偏移量（这是该文件的哪一块）。该信息记录在一个数据结构中，位于段头部。

**过程：**

1. 查看段摘要块并很到其 inode 号 N 和偏移量 T。接下来，查看 imap 以很到 N 所在的位置，并从磁盘读取 N
2. 最后，利用偏移量 T，查看 inode（或某个间接块），看看 inode 认为此文件的第 T 个块在磁盘上的位置。
3. 它刚好指向磁盘地址 A，则 LFS可以断定块 D 是活的。如果它指向其他地方，LFS 可以断定 D 未被使用

## 策略问题：要清理哪些块，何时清理

**分离冷热段：**最好的策略是在清理之前等待很长时间，因为越来越多的块被覆盖（在新的段中），从而被释放以供使用。应该尽快清理冷段，延迟清理热段，并开发出一种完全符合要求的试探算法

**并非最佳方法**



## 崩溃恢复和日志 

- 确保 CR 更新以原子方式发生，LFS 实际上保留了两个CR，每个位于磁盘的一端，并交替写入它们
- **谨慎的协议：**它首先写出一个头（带有时间戳），然后写出 CR 的主体，然后最后写出最后一部分。如果系统在 CR 更新期间崩溃，LFS 可以通过查看一对不一致的时间戳来检测到这一点。LFS 将始终选择使用具有一致时间戳的最新 CR，从而实现 CR 的一致更新





