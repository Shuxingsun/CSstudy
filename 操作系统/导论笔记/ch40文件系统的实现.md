# 文件系统的实现

**关键问题：如何实现简单的文件系统**

> 如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？

## 思考方式

- 文件系统的数据结构
- 文件系统的访问方式



## 整体组织

需要做的第一件事是将磁盘分成块。

系列块，每块大小为 4KB。在大小为 N 个 4KB 块的分区中，这些块的地址为从 0 到 N−1。

- 存放用户数据的磁盘区域称为**数据区域**。

- 为了存储这些信息，文件系统通常有一个名为 inode 的结构

假设我们将 64 个块中的 5 块用于 inode

- 还需要某种方法来记录 inode 或数据块是空闲还是已分配。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲**称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于 inode 表。**
- 还有一块。我们将它保留给超级块。它可能还包括一些幻数，来标识文件系统类型。

<img src="https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-17_10-56-30.png" style="zoom:100%;" />



## 文件组织：inode(index node 索引节点)

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-17_10-58-54.png)

- 每个 inode 都由一个数字（称为 inumber）隐式引用，我们之前称之为文件的低级名称(low-level name)
- 给定一个 inumber，你应该能够直接计算磁盘上相应节点的位置
- 设计 inode 时，最重要的决定之一是它**如何引用数据块的位置**
  - 一种简单的方法是在inode 中有**一个或多个直接指针.每个指针指向属于该文件的一个磁盘块**。这种方法有局限：例如，如果你想要一个非常大的文件(例如,大于块的大小乘以直接指针数),那就不走运了。

### 多级索引

#### **间接指针：**

- 为了支持更大的文件，文件系统设计者必须在 inode 中引入不同的结构。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据
- inode 可以有一些固定数量的直接指针和一个间接指针
- 假设一个块是 4KB，磁盘地址是 4 字节，那就增加了 1024 个指针。文件可以增长到（12 + 1024）×4KB，即 4144KB

#### 双重间接指针：支持更大的文件

- 该指针指的是一个包含间接块指针的块，每个间接块都包含指向数据块的指针
- 双重间接块提供了可能性，允许使用额外的 1024×1024 个 4KB 块来增长文件，换言之，支持超过 4GB 大小的文件。

#### 多级索引

许多文件系统使用多级索引，包括常用的文件系统



## 目录组织

**目录组织**：一个目录基本上只包含一个二元组（条目名称，inode 号）的列表。

|inum | reclen | strlen | name |

| 5| 4 |2 |. |
| 2 |4| |3 |.. |

| 12| 4 |4 |foo |

 |13 |4 |4 |bar |

 |24| 8 |7 |foobar |

每个条目都有一个 inode 号，记录长度（名称的总字节数加上所有的剩
 余空间），字符串长度（名称的实际长度），最后是条目的名称



## 空闲内存管理

文件系统必须记录哪些 inode 和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间。



## 访问路径：读取和写入

对于下面的例子，我们假设文件系统已经挂载，因此超级块已经在内存中



### 从磁盘读取文件

1. 当你发出一个 open("/foo/bar", O_RDONLY)调用时，文件系统首先需要找到文件 bar 的inode，从而获取关于该文件的一些基本信息
2. 所有遍历都从文件系统的根开始，即根目录。根的 inode 号为 2。因此，要开始该过程，文件系统会读入 inode 号 2 的块（第一个 inode 块）。
3. 一旦 inode 被读入，文件系统可以在其中查找指向数据块的指针，数据块包含根目录的内容。因此，文件系统将使用这些磁盘上的指针来读取目录。
4. 打开后，程序可以发出 read()系统调用，从文件中读取。



### 写入磁盘

- 写入文件是一个类似的过程。首先，文件必须打开（如上所述）。其次，应用程序可以发出 write()调用以用新内容更新文件。最后，关闭该文件。
- 写入文件也可能会**分配（allocate）一个块**（除非块被覆写）。当写入一个新文件时，每次写入操作不仅需要将数据写入磁盘，还必须首先决定将哪个块分配给文件，从而相应地更新磁盘的其他结构（例如数据位图和 inode）。
- 因此，**每次写入文件在逻辑上会导致 5 个 I/O**：一个读取数据位图（然后更新以标记新分配的块被使用），一个写入位图（将它的新状态存入磁盘），再是两次读取，然后写入 inode（用新块的位置更新），最后一次写入真正的数据块本身



## 缓存和缓冲

读取和写入文件可能是昂贵的，会导致（慢速）磁盘的许多 I/O。这显然是一个巨大的性能问题。

- 静态的内存划分（static partitioning）可能导致浪费
- 现代系统采用动态划分（dynamic partitioning）方法。许多现代操作系统将虚拟内存页面和文件系统页面集成到统一页面缓存中。

- **写缓冲的优点：**
  - 延迟写入，文件系统可以将一些更新编成一批（batch），放一组较小的 I/O 中
  - 通过将一些写入缓冲在内存中，系统可以调度（schedule）后续的 I/O，从而提高性能
  - 些写入可以通过拖延来完全避免

