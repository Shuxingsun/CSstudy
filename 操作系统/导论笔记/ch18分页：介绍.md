# 分页：介绍

**两种方法管理空间问题：**

- 分段：将空间分割成不同长度的分片。空间会碎片化
- 分页：将空间分割成固定长度的分片（单元），每个单元称一页
  - 页帧：物理内存看成是定长槽快的阵列
  - 每个页帧包含一个虚拟内存页

**关键问题：**

> 如何通过页来实现虚拟内存，从而避免分段的问题？基本技术是什么？如何让这些技术运行良好，并尽可能减少空间和时间开销？

## 一个简单例子

- 物理内存和地址空间的对应关系。物理内存8个页帧，虚拟地址页放在物理内存的不同位置

  ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_11-45-05.png)

- **分页优点**

  - 灵活性：操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间
  - 简单性

- **页表**：记录地址空间的每个虚拟页放在物理内存中的位置。**页表是每一个进程的数据结构**

- **转换过程**

  - 两组件：虚拟页面号(virtual page number, `VPN`)、页内偏移量(offset)

  - 根据页的字节大小，判断多少个页面，然后算出`VPN`,和偏移量，最后`VPN->PFN`。偏移量等于页的大小位数

  - 例子：虚拟地址空间64字节，页大小16字节。得出4个页，两位数表示。

    ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_11-52-25.png)

  - **地址转换过程**

    - **物理帧**（`PFN\PPN`，physical page number）

    - `PFN->VPN`:已知物理帧是7

      ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_12-01-10.png)

## 页表存在哪里

我们没有在 `MMU` 中利用任何特殊的片上硬件，来存储当前正在运行的进程的页表，而是将每个进程的**页表存储在内存中**

## 列表中究竟有什么

- 线性页表--数组

  - 操作系统通过虚拟页号（`VPN`）检索该数组，并在该索引处查找页表项（`PTE`），以便找到期望的物理帧号（`PFN`）。

- **`PTE`内容：位数**

  - 有效位：（valid bit）通常用于指示特定地址转换是否有效。**有效位对于支持稀疏地址空间至关重要**

  - 保护位(protection bit)：表明页是否可以读取、写入或执行

  - 存在位(present bit)：表明该页是在物理存储器还是在磁盘上。交换允许操作系统将很少使用的页面移到磁盘，从而释放物理内存

  - 脏位(dirty bit)：表明页面被带入内存后时候被修改过

  - 参考位(reference bit)（访问位(accessed bit)）：追踪页是否被访问，也可以确定哪些页很受欢迎，可以保留在内存中

  - **一个页表项**

    ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_12-21-51.png)

## 分页：也很慢

内存中的页表，我们已经知道它们可能太大了。事实证明，**它们也会让速度变慢**

**硬件如何知道当前正在运行的进程的页表的位置**

- 你可以想象 `PFN` 被 `SHIFT`左移，**然后与偏移量进行逻辑或运算，以形成最终地址**

- 举例：

  ```html
  它从完整的虚拟地址中挑选出 VPN 位；SHIFT 设置为 4（偏移量的位数），这样我们就可以将VPN 位向右移动以形成正确的整数虚拟页码。例如，使用虚拟地址 21（010101），掩码将此值转换为 010000，移位将它变成01，或虚拟页 1，正是我们期望的值
  ```

## 内存追踪

**演示使用分页时产生的所有内存访问**

## 小结

**分页优点：**

- 不会导致外部碎片
- 非常灵活，支持稀疏虚拟地址空间

**分页缺点：**

- 较慢机器（额外的内存访问页表）
- 内存浪费（内存被页表塞满而不是有用的应用程序数据）



## 英语名词

- 虚拟页面号(virtual page number, `VPN`)
- **物理帧**（`PFN\PPN`，physical page number）
- 页表项（`PTE`）