# 崩溃一致性：FSCK和日志

<u>这一节知识点比较难理解，粗记一下</u>

**崩溃一致性问题：**由于断电和崩溃，更新持久性数据结构可能非常棘手，并导致了文件系统实现中一个有趣的新问题

**关键问题：考虑到崩溃，如何更新磁盘**

> 系统可能在任何两次写入之间崩溃或断电，因此磁盘上状态可能仅部分地更新。崩溃后，系统启动并希望再次挂载文件系统（以便访问文件等）。鉴于崩溃可能发生在任意时间点，如何确保文件系统将磁盘上的映像保持在合理的状态？



**两种方法：**

- FSCK,文件系统检查程序
- 日志记录





## 一个详细的例子

FROM

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-18_19-47-52.png)

TO

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-18_19-48-33.png)

文件系统必须对磁盘执行 3 次单独写入，分别针对 inode（I[v2]），位图（B[v2]）和数据块（Db）.

**崩溃场景**

- **只将数据块（Db）写入磁盘**。在这种情况下，数据在磁盘上，但是没有指向它的inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题
- **只有更新的 inode（I[v2]）写入了磁盘**。在这种情况下，inode 指向磁盘地址（5），其中 Db 即将写入，但 Db 尚未写
- **只有更新后的位图（B [v2]）写入了磁盘**。在这种情况下，位图指示已分配块 5，但没有指向它的 inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块 5
- **inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）**。在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示 5正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5 中又是垃圾。
- **写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）**。在这种情况下，inode 指向了磁盘上的正确数据，但同样在 inode 和位图（B1）的旧版本之间存在不一致
- **写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）**。在这种情况下，inode 和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，我们也不知道它属于哪个文件，因为没有 inode 指向该块

**崩溃一致性问题**

问题：在文件系统数据结构中可能存在不一致性。可能有空间泄露，可能将垃圾数据返回给用户，等等

理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地(atomically)移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是，做到这一点不容易，**因为磁盘一次只提交一次写入，而这些更新之间可能会发生崩溃或断电**。我们将这个一般问题称为**崩溃一致性问题**



## 解决方案 1：文件系统检查程序 

**思想：** 基本上，它们决定让不一致的事情发生，然后再修复它们