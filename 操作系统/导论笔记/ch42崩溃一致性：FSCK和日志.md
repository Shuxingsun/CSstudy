# 崩溃一致性：FSCK和日志

<u>这一节知识点比较难理解，粗记一下</u>

**崩溃一致性问题：**由于断电和崩溃，更新持久性数据结构可能非常棘手，并导致了文件系统实现中一个有趣的新问题

**关键问题：考虑到崩溃，如何更新磁盘**

> 系统可能在任何两次写入之间崩溃或断电，因此磁盘上状态可能仅部分地更新。崩溃后，系统启动并希望再次挂载文件系统（以便访问文件等）。鉴于崩溃可能发生在任意时间点，如何确保文件系统将磁盘上的映像保持在合理的状态？



**两种方法：**

- FSCK,文件系统检查程序
- 日志记录





## 一个详细的例子

FROM

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-18_19-47-52.png)

TO

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-18_19-48-33.png)

文件系统必须对磁盘执行 3 次单独写入，分别针对 inode（I[v2]），位图（B[v2]）和数据块（Db）.

**崩溃场景**

- **只将数据块（Db）写入磁盘**。在这种情况下，数据在磁盘上，但是没有指向它的inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题
- **只有更新的 inode（I[v2]）写入了磁盘**。在这种情况下，inode 指向磁盘地址（5），其中 Db 即将写入，但 Db 尚未写
- **只有更新后的位图（B [v2]）写入了磁盘**。在这种情况下，位图指示已分配块 5，但没有指向它的 inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块 5
- **inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）**。在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示 5正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5 中又是垃圾。
- **写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）**。在这种情况下，inode 指向了磁盘上的正确数据，但同样在 inode 和位图（B1）的旧版本之间存在不一致
- **写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）**。在这种情况下，inode 和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，我们也不知道它属于哪个文件，因为没有 inode 指向该块

**崩溃一致性问题**

问题：在文件系统数据结构中可能存在不一致性。可能有空间泄露，可能将垃圾数据返回给用户，等等

理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地(atomically)移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是，做到这一点不容易，**因为磁盘一次只提交一次写入，而这些更新之间可能会发生崩溃或断电**。我们将这个一般问题称为**崩溃一致性问题**



## 解决方案 1：文件系统检查程序 

**思想：** 基本上，它们决定让不一致的事情发生，然后再修复它们

**基本总结**

- **超级块**：fsck 首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。
- **空闲块**：接下来，fsck 扫描 inode、间接块、双重间接块等，以了解当前在文件系统中分配的块
- **inode** 状态：检查每个 inode 是否存在损坏或其他问题
- **inode** 链接：fsck 还会验证每个已分配的 inode 的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量
- **重复**：fsck 还检查重复指针，即两个不同的 inode 引用同一个块的情况
- **坏块**：在扫描所有指针列表时，还会检查坏块指针
- **目录检查**：fsck 不了解用户文件的内容



## 解决方案 2：日志（或预写日志）

**预写日志：**解决方案可能是从数据库管理系统的世界中借鉴的一个想法

**基本思路：**

1. 在覆写结构之前，首先写下一点小注记
2. 通过将注释写入磁盘，可以保证在更新（覆写）正在更新的结构期间发生崩溃时，够返回并查看你所做的注记
3. 你会在崩溃后准确知道要修复的内容（以及如何修复它），而不必扫描整个磁盘

日志如下:

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_10-36-06.png)



### 数据日志

数据更新，日志的基本操作顺序：

1. **日志写入**：将事务（包括事务开始块，所有即将写入的数据和元数据更新以及事务结束块）写入日志，等待这些写入完成。
2. **日志提交**：将事务提交块（包括 TxE）写入日志，等待写完成，事务被认为已提交
3. **加检查点**：将待处理的元数据和数据更新写入文件系统中的最终位置。

FROM

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_10-38-49.png)

TO

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-19_10-39-36.png)

### 恢复

....



### 批处理日志更新

.....



### 使日志有限

.....



### 元数据日志

......



### 棘手情况：块复用

.....



### 总结日志：时间线

....



## 解决方案 3：其他方法 

- 基于 fsck 的偷懒方法
- 称为日志的更活跃的方法
- 写时复制。这种技术永远不会覆写文件或目录。相反，它会对磁盘上以前未使用的位置进行新的更新
- 基于反向指针的一致性。它在写入之间不强制执行排序
- 乐观崩溃一致性。尽可能多地向磁盘发出写入，并利用**事务校验和**（transaction checksum）[P+05]的一般形式，以及其他一些技术来检测不一致，如果出现不一致的话。对于某些工作负载，这些乐观技术可以将性能提高一个数量级。但是，要真正运行良好，需要稍微不同的磁盘接口

