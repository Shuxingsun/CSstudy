# 空闲地址空间管理

**关键问题：如何管理空闲空间**

要满足变长的分配请求，**应该如何管理空闲空间？什么策略可以让碎片最小化**？不同方法的时间和空间开销如何？

## 假设

**空闲列表：**在堆上管理空闲空间的数据结构

- 假设一：如果分配程序给出的内存块超出请求的大小，在这种块中超出请求的空间（因此而未使用）就被认为是内部碎片
- 假设二：内存一旦被分配给客户，就不可以被重定位到其他位置。
- 假设三：分配程序所管理的是连续的一块字节区域。<u>分配程序会使得这块区域增长</u>，**但我们假设这块区域不变**

## 底层机制

**大多数分配程序采用的通用机制：**

1. 讨空间分割与合并的基本知识
2. 看看如何快速并相对轻松地追踪已分配的空间
3. 讨论如何利用空闲区域的内部空间维护一个简单的列表，来追踪空闲和已分配的空间

### 分割和合并

空闲列表：

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-39-38.png)

空闲列表里的元素：一个描述第一个10字节的空闲区域（字节0～9），一个描述另一个空闲区域（字节 20～29）

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-39-58.png)

**分割**：申请一个字节，可以看出，空闲列表基本没有变化，只是第二个空闲区域的起始位置由 20 变成21，长度由 10 变为 9 了。

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-43-21.png)

**合并：**还是看前面的例子（10字节的空闲空间，10 字节的已分配空间，和另外 10 字节的空闲空间）。

可能出现的结果：

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-44-55.png)

**问题：**分隔成 3 个 10 字节的区域。这时，如果用户请求 20 字节的空间，简单遍历空闲列表会找不到这样的空闲块，因此返回失败。

**分配程序会在释放一块内存时合并可用空间**：![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-46-17.png)

### 追踪已分配空间的大小

要完成这个任务，大多数分配程序都会在**头块（header）中保存一点额外的信息**，它在内存中，通常就在返回的内存块之前

**简单头快:**大小+幻数.

幻数：提供完整性检查

```c
typedef struct header_t { 
 int size; 
 int magic; 
} header_t;
```

**加速空间释放**

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-50-53.png)

**实际释放的是头块大小加上分配给用户的空间的大小**

### 嵌入空闲列表

- 初始化表
- 初始化堆

.......

### 让堆增长

**堆增长（系统调用）**——大多数传统的分配程序会从很小的堆开始，当空间耗尽时，再向操作系统申请更大的空间

## 基本策略

**理想的分配程序可以同时保证快速和碎片最小化**

### 最优匹配

- 首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。
- 遍历查找正确的空闲块时，要**付出较高的性能代价**。

### 最差匹配

- 它尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。
- 遍历查找正确的空闲块时，要**付出较高的性能代价。**

**首次匹配**

- 找到第一个足够大的块，将请求的空间返回给用户
- 速度优势，但会使得产生很多小块
- 分配程序如何管理空闲列表的顺序
  - 基于地址排序：通过保持空闲块按内存地址有序，合并操作会很容易，从而减 少了内存碎片。

### 下次匹配

- 多维护一个指针，指向上一次查找结束的位置。
- 避免对列表开头频繁的分割。与首次匹配很接它，**同样避免了遍历查找**。

## 其他方式

### 分离空闲列表

- 如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。

- 通过拿出一部分内存专门满足某种大小的请求，碎片就不再是问题。但会引入新复杂性——拿出多少的内存。
  - 超级工程师 Jeff Bonwick为 Solaris 系统内核设计的厚块分配程序（slab allocator）
  - 锁和文件系统 inode 等。这些的对象缓存每个分离了特定大小的空闲列表
  - 如果某个缓存中的空闲空间快耗尽时，它就向通用内存分配程序申请一些内存厚块

### 伙伴系统

- 当有一个内存分配 请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小。
- 这种分配策略只允许分配 2 的整数次幂大小的空闲块，因此会有**内部碎片**（internal fragment）的麻烦

- **优秀之处：快被释放时**
  - 分配程序会检查“伙伴”8KB 是否空闲。如果是，就合二为一，变成 16KB 的块。然后会检查这
     个 16KB 块的伙伴是否空闲，如果是，就合并这两块。









