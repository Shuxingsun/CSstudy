# 第六章：受限直接执行

```markdown
**关键问题：如何高效。可控地虚拟化CPU**

```

## 基本技巧：受限直接执行（`LDE`）

- 直接执行：只需要在CPU上运行程序

- 运行过程：当 OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。表 6.1 展示了这种基本的直接执行协议（没有任何限制），使用正常的调用并返回跳转到程序的 main()，并在稍后回到内核。
- 面临问题
  - 怎么确保程序不会做任何我们不希望他做的事请
  - 怎么样将它停下来，切换到另一个进程

## 问题1：受限制地操作

**采用不同的处理器模式**

- 用户模式(user mode)
  - 在该模式下，运行代码会受限制，例如IO操作
- 内核模式(kernel mode)
  - 可以做任何想做地事

**系统调用**：用户执行特权操作地能力

系统调用必须执行**特殊陷阱**指令，该指令同时跳入内核并将特权级别提升到内核模式。

**注意事项**

- 因为它必须确保存储足够的调用者寄存器
- 陷阱如何知道在 OS 内运行哪些代码？
  - 内核通过在启动时设置陷阱表（trap table）来实现;
  - 陷阱表的功能：是告诉硬件在发生某些异常事件时要运行哪些代码

**LED协议的两个阶段**

- 第一个阶段（在系统引导时），内核初始化陷阱表，并且 CPU 记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体突出显示）。

- 第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）

## 问题2：在进程之间切换

```mark
关键问题：如何重获CPU控制权
```

### 协作方法：等待系统调用

- 大多数进程通过进行**系统调用**，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程

- 如果应用程序执行了**某些非法操作**，也会将控制转移给操作系统

在协作方式中，当**进程陷入无限循环**时，唯一的办法就是使用古老的解决方案来解决计算机系统中的所有问题——**重新启动计算机

### 非协作方法：操作系统进程控制

**时钟中断：**每隔一段时间，产生中断。。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权

### 保存和恢复上下文

针对重新获得控制权后，选择运行当前进程还是切换另一个进程。

**上下文切换**是针对切换进程时做的操作

上下文切换：操作系统要做的就是为**当前正在执行的进程保存一些寄存器的值**（例如，到它的内核栈），并为**即将执行的进程恢复一些寄存器的值**（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。

## 小结

CPU 虚拟化的**关键底层机制**，并将其统称为受限直接执行。

让程序在CPU上运行，但首先确保设置好硬件，以便在没有操作系统帮助的情况下限制进程可以执行的操作。

**等价于**那些有孩子或至少听说过孩子的人可能会熟悉宝宝防护（baby proofing）房间的概念——锁好包含危险物品的柜子，并掩盖电源插座。当这些都准备妥当时，你可以让宝宝自由行动，确保房间最危险的方面受到限制。