# 分页：快速地址转换（TLB）

**关键问题:如何加速地址转换**

> 如何才能加速虚拟地址转换，尽量避免额外的内存访问？需要什么样的硬件支持？操作系统该如何支持？

硬件帮助——**地址转换缓存**（地址转换旁路缓冲存储器（`TLB`））

## `TLB`的基本算法

```c
1 VPN = (VirtualAddress & VPN_MASK) >> SHIFT  //提取页号
2 (Success, TlbEntry) = TLB_Lookup(VPN) //检查是否有转换映射
3 if (Success == True) // TLB Hit 有映射
4 	if (CanAccess(TlbEntry.ProtectBits) == True) 
5 		Offset = VirtualAddress & OFFSET_MASK //页帧号，物理地址
6 		PhysAddr = (TlbEntry.PFN << SHIFT) | Offset //物理地址
7 		AccessMemory(PhysAddr)   //访问内存
8 	else 
9 		RaiseException(PROTECTION_FAULT) 
10 	else // TLB Miss 
11 		PTEAddr = PTBR + (VPN * sizeof(PTE))   //寻找转换映射，也表查询
12 		PTE = AccessMemory(PTEAddr)    //内存引用
    		if (PTE.Valid == False) 
14 				RaiseException(SEGMENTATION_FAULT) 
15 			else if (CanAccess(PTE.ProtectBits) == False) 
16 				RaiseException(PROTECTION_FAULT) 
17 			else 
18 				TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)  // 更新TLB
19 				RetryInstruction()
```



## 访问数组

### **例子：**

> 10 个 4 字节整型数组成的数组，起始虚地址是 100。

我们可以把虚地址划分为 4 位的 `VPN`（有 16 个虚拟内存页）和 4 位的偏移量.

### 分析

数组的第一项（a[0]）开始于（`VPN=06`，offset=04），只有 3 个 4 字节整型数存放在该页。数组在下一页（`VPN=07`）继续，其中有接下来 4 项（a[3] … a[6]）。10 个元素的数组的最后 3 项（a[7] … a[9]）位于地址空间的下一页（`VPN=08`）。

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_12-38-23.png)

**循环访问过程**：

假设这里是程序第一次访问该数组，结果是 `TLB` 未命中。接下来访问 a[1]，`TLB` 命中！<u>因为数组的第二个元素在第一个元素之后，它们在同一页。因为我们之前访问数组的第一个元素时，已经访问了这一页</u>。

遗憾的是，当程序访问 a[3]时，会导致 `TLB` 未命中。但同样，接下来几项（a[4] … a[6]）都会命中 `TLB`，因为它们位于内存中的同一页。

访问 a[7]会导致最后一次 `TLB` 未命中。系统会再次查找页表，弄清楚这个虚拟页在物理内存中的位置，并相应地更新 `TLB`。最后两次访问（a[8]、a[9]）受益于这次 `TLB`更新，当硬件在 `TLB` 中查找它们的转换映射时，两次都命中

**`TLB` 的行为表现**：未命中、命中、命中、未命中、命中、命中、命中、未命中、命中、命中

**页大小对结果的影响**：如果页大小变大一倍（32 字节，而不是 16），数组访问遇到的未命中更少。

**`TLB`性能**：如果在这次循环后不久，该程序再次访问该数组，我们
 会看到更好的结果，假设 `TLB` 足够大，能**缓存所需的转换映射**

- **尽可能利用缓存**
  - 硬件缓存背后的思想是利用指令和数据引用的局部性
    - 时间局部性
      - 最近访问过的指令或数据项可能很快会再次访问
    - 空间局部性
      - 当程序访问内存地址 x 时，可能很快会访问邻近 x 的内存

## 谁来处理`TLB`未命中

- **硬件全权处理`TLB`**
  - 硬件必须知道页表在内存中的确切位置（通过页表基址寄存器，
     `page-table base register`，在图 19.1 的第 11 行使用），以及页表的确切格式
- **软件管理`TLB`**
  - 硬件系统会抛出一个异常（见图 19.3 第 11 行），这会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序
  - 这个陷阱处理程序是操作系统的一段代码，用于处理 `TLB` 未命中.这段代码会查找页表中的转换映射，然后用特别的“特权”指令更新 `TLB`
  - **从陷阱返回指令与从系统调用的从陷阱返回指令不同之处**
    - <u>系统调用，会继续执行此次调用之后的语句</u>
    - <u>而从`TLB`未命中的陷阱返回喉，硬件必须从导致陷阱的指令继续执行</u>
  - 在运行 `TLB` 未命中处理代码时，操作系统需要格外小心避免引起 `TLB` 未命中的无限递归

## `TLB`的内容

**典型的 `TLB`** 有 32 项、64 项或 128 项，并且是全相联的（fully associative）。

**`TLB`内容大致为：**`VPN | PFN |其它位`

**`TLB`有效位 != 页表有效位：**

- 如果一个页表项（`PTE`）被标记为无效，就意味着该页并没有被进程申请使用，正常运行的程序不应该访问该地址
- `TLB` 的有效位不同，只是指出 `TLB` 项是不是有效的地址映射。



## 上下文切换时对`TLB`的处理

**`TLB` 中包含的虚拟到物理的地址映射只对当前进程有效，对其他进程是没有意义的**

### 例子

> 假设还有一个进程（`P2`），操作系统不久后决定进行一次上下文切换，运行 `P2`。这里假定 `P2` 的 10 号虚拟页映射到 170 号物理帧。如果这两个进程的地址映射都在 `TLB` 中

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_15-48-22.png)

但硬件分不清哪个项属于哪个进程。所以我们还需要做一些工作，让 `TLB` **正确而高效地支持跨多进程的虚拟化**

**关键问题：进程切换时，如何管理`TLB`内容**

> 如果发生进程间上下文切换，上一个进程在 `TLB` 中的地址映射对于即将运行的进程是无意义的.硬件或操作系统应该做些什么来解决这个问题呢？

**办法：**一种方法是在上下文切换时，**简单地清空（flush）`TLB`，**
**这样在新进程运行前 `TLB` 就变成了空的**

每次进程运行，当它访问数据和代码页时，都会触发 `TLB` 未命
 中。如果**操作系统频繁地切换进程，这种开销会很高**

**避免开销：**些系统增加了硬件支持，实现跨上下文切换的 `TLB` 共享。比如
 有的系统在 `TLB` 中添加了一个**地址空间标识符**（Address Space Identifier，`ASID`）。

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_15-54-03.png)



- 不同进程的两项，将两个不同的`VPN`指向相同的物理页。——共**享代码页**（以二进制或共享库的方式）是有用的，因为它减少了物理页的使用，从而减少了内存开销。

  ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_15-55-29.png)



## `TLB`替换策略

 **缓存替换：**具体来说，向 `TLB` 中插入新项时，会替换（replace）一个旧项

**关键问题：如何设计`TLB`替换策略**

> 在向 `TLB` 添加新项时，应该替换哪个旧项？目标当然是减小 `TLB` 未命中率（或提高命中率），从而改进性能

 **策略：**

- 替换最近最少使用（`least-recently-used，LRU`）的项
- 随机（random）策略，随机选择一项换出去

## 实际系统的`TLB`策略

`MIPS R400`系统的软件管理`TLB`:

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-03_15-59-37.png)

**`MIPS TLB` 一些有趣的标识位:**

- 全局位（Global，G），用来指示这个页是不是所有进程全局共享的.全局位置为 1，就会忽略 `ASID`
- `ASID`:区分进程空间
- 个一致性位（Coherence，C），决定硬件如何缓存该页
- 脏位（dirty），表示该页是否被写入新数据
- 有效位（valid），告诉硬件该项的地址映射是否有效

**`MIPS` 管理`TLB`的指令：**

- `TLBP`，用来查找指定的转换映射是否在 `TLB` 中
- `TLBR`，用来将 `TLB`中的内容读取到指定寄存器中
- `TLBWI`，用来替换指定的 `TLB` 项
- `TLBWR`，用来随机替换一个 `TLB` 项



## 英语名词

- 快速地址转换（`TLB`）
- **地址空间标识符**（Address Space Identifier，`ASID`）。

