# 多级反馈队列（`MLFQ`）

**解决两个问题：**

- 优化周转时间
- 更好的交互体验，降低响应时间

<u>多级反馈队列是用**历史经验预测未来**的一个典型的例子</u>

## MLFQ：基本规则

**关键：**如何设置优先级

- **规则1：**如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
- **规则2：**如果 A 的优先级 = B 的优先级，轮转运行A 和 B
- **规则3：**工作进入系统时，放在最高优先级（最上层队列）
- **规则 `4a`：**工作用完整个时间片后，降低其优先级（移入下一个队列）。
- **规则 `4b`：**如果工作在其时间片以内主动释放 CPU，则优先级不变。
- `4a,4b`不考虑了
- **规则 4：**一旦工作<u>用完了其在某一层中的时间配额</u>（无论中间主动放弃了多少次CPU），就<u>降低其优先级</u>（移入低一级队列）。
  - **阻止调度程序被愚弄**
  - 愚弄调度程序指的是用<u>一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源</u>。上述算法对如下的攻击束手无策：进程在时间片用完之前，**调用一个 I/O 操作**（比如访问一个无关的文件）。**如此便可以保持在高优先级**，占用更多的 CPU 时间。做得好时（比如，每运行 99%的时间片时间就主动放弃一次 CPU），工作可以几乎独占 CPU。
- **规则5：**经过一段时间 *S*，就将系统中所有工作重新加入最高优先级队列。
  - **避免饥饿问题**
  - 时间段 S 导致了明显的问题：S 的值应该如何设置？
  - 这个值被称为巫毒常量（`voo-doo constant`）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例

## 小结

`MLFQ`:它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级

**五大规则：**

