# 并发介绍

- **线程:**每个线程类似于独立的的进程，不过线程是共享地址空间，从而能访问相同数据

- 线程有一个程序计数器（PC），记录程序从哪获得指令

- 线程的上下文切换类型进程的上下文切换，将状态保存到线程控制块（PCB）不同点在于：**地址空间保持不变**

- 线程与进程的栈不同。

  - 单线程进程只有一个栈，位于地址空间底部。
  - 多线程进程，在地址空间里，每个线程都有一个栈。

  ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-08_12-10-33.png)

  

## 线程创建

- 主程序创建了两个线程，分别执行函数 `mythread`()，主程序调用 `pthread_join`()，等待特定线程完成

- ```c
  1 #include <stdio.h> 
  2 #include <assert.h> 
  3 #include <pthread.h> 
  4 
  5 void *mythread(void *arg) { 
  6 printf("%s\n", (char *) arg); 
  7 return NULL; 
  8 } 
  9 
  10 int 
  11 main(int argc, char *argv[]) { 
  12 pthread_t p1, p2; 
  13 int rc; 
  14 printf("main: begin\n"); 
  15 rc = pthread_create(&p1, NULL, mythread, "A"); assert(rc == 0); 
  16 rc = pthread_create(&p2, NULL, mythread, "B"); assert(rc == 0); 
  17 // join waits for the threads to finish 
  18 rc = pthread_join(p1, NULL); assert(rc == 0); 
  19 rc = pthread_join(p2, NULL); assert(rc == 0); 
  20 printf("main: end\n"); 
  21 return 0; 
  22 }
  ```

- 程序的可能执行顺序不同。线程创建的不唯一性，它可以独立于调用者运行，可能在从创建者返回之前运行，但也许会晚得多。很难说什么时候运行，什么时候等待

## 为什么更糟糕：共享数据

- 线程更新全局共享变量

- 会使得产生不确定的效果

- 每次运行不但会产生错误，而且得到不同的结果

  ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-08_12-18-10.png)

## 核心问题：不可控调度

- 我们必须了解编译器为更新计数器生成的代码序列。

- 变量 counter 位于地址 0x8049a1c。在这 3 条指令中，先用 x86 的 mov指令，从内存地址处取出值，放入 eax。然后，给 eax 寄存器的值加 1（0x1）。最后，eax 的值被存回内存中相同的地址.

- ```c
  mov 0x8049a1c, %eax 
  add $0x1, %eax 
  mov %eax, 0x8049a1c
  ```

- 一件不幸的事情发生了：**时钟中断发生**。因此，
  操作系统将当前正在运行的线程（它的程序计数器、寄存器，包括 eax 等）的状态保存到线程的 TCB。

- **运行时每个线程都有自己的专用寄存器**。上下文切换代码将寄存器虚拟化（virtualized），保存并恢复它们的值

- 执行过程：

  - ```
    1. 设想我们的两个线程之一（线程 1）进入这个代码区域，并且因此将要增加一个计数器。它将 counter 的值（假设它这时是50）加载到它的寄存器 eax 中。因此，线程   1 的 eax = 50。然后它向寄存器加1，因此 eax = 51
    
    2. 线程 2 被选中运行，并进入同一段代码。它也执行了第一条指令，获取计数器的值并将其放入其 eax 中.此时 counter 的值仍为 50，因此线程 2 的 eax = 50。假设线程 2 执行接下来的两条指令，将 eax 递增 1（因此 eax = 51），然后将 eax 的内容保存到 counter（地址 0x8049a1c）中。因此，全局变量 counter 现在的值是51。
    
    3.最后，又发生一次上下文切换，线程 1 恢复运行。还记得它已经执行过 mov 和 add 指令，现在准备执行最后一条 mov 指令。回忆一下，eax=51。因此，最后的 mov 指令执行，将值保存到内存，counter 再次被设置为 51。
    ```

- **竞态条件**：相互竞争。结果取决于代码的时间执行

## 原子性愿望

**另一种途径**：单步就能完成要做的事，从而消除不合时宜的中断的可能性——**比如超级指令**



**并发术语：**

- **临界区**（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。
- **竞态条件**（race condition）出现在多<u>个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构</u>，导致了令人惊讶的（也许是不希望的）结果。
- **不确定性**（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。



## 另一个问题：等待另一个线程

另一种常见的交互：即一个线程在继续之前必须等待另一个线程完成某些操作

例如：

>  当进程执行磁盘 I/O 并进入睡眠状态时，会产生这种交互。当 I/O 完成时，该进程需要从睡眠中唤醒