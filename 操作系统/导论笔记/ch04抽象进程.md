# 抽象：进程

**非正式定义：**运行中的程序

**关键问题**

```
关键问题：如何提供有许多 CPU 的假象？
虽然只有少量的物理 CPU 可用，但是操作系统如何提供几乎有无数个 CPU 可用的假象？
```

- 操作系统通过虚拟化（`virtualizing`）CPU 来提供这种假象。
- **时分共享（time sharing）CPU 技术:**
  - 通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。，允许用户如愿运行多个并发进程。

- **潜在的开销**就是性能损失，因为如果 CPU 必须共享，每个进程的运行就会慢一点。

## 抽象，进程

**进程：** <u>操作系统为正在运行的程序提供的抽象</u>

**机器状态：**程序在运行时可以读取或更新的内容	

- 组成部分：
  - 内存：指令存在内存，程序读取写入的数据。
  - 寄存器：许多的指令明确的读取或更新寄存器
    - 特殊的寄存器，程序计数器

## 进程API

**结构包含的内容：**

- 创建（`create`）
- 销毁（`destory`）

- 等待（`wait`）
- 其他控制（`miscelllanenous control`）
- 状态（`statu`）

## 进程创建：更多细节

**程序如何转换为进程？**

- 将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。

![](https://picture-house.oss-cn-beijing.aliyuncs.com/course/1.png)

- 必须为程序的运行时栈（`run-time stack 或 stack`）分配一些内存
- 也可能为程序的堆（`heap`）分配一些内存。 
- 执行一些其他初始化任务

<u>通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，OS 现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序，在入口处运行，即 main()。</u>

## 进程状态

**三种状态**

- 运行
- 就绪
- 阻塞（blocked）

![](https://picture-house.oss-cn-beijing.aliyuncs.com/course/2.png)

**进程还有其他的状态**

- 有时候系统会有一个初始（`initial`）状态，表示进程在创建时处于的状态
- 处于已退出但尚未清理的最终（`final`）状态
  - 因为它允许其他进程（通常是创建进程的父进程）**检查进程的返回代码**，并查看刚刚完成的进程是否成功执行（通常，在基于 `UNIX` 的系统中，程 序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如， `wait`()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关
     数据结构。

