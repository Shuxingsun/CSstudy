# 机制：地址转换

### 关键问题：如何高效、灵活地虚拟化内存

如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制应用程序可访问的内存位置，从而确保应用程序的内存访问受到合理的限制？如何高效地实现这一切？

**通用技术**基于硬件的地址转换（`hardware-based address  translation`），简称为地址转换（`address translation`）。

- 硬件支持：利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此，在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置
- 操作系统关键位置介入

## 假设

先假设用户的地址空间必须连续地放在物理内存中。同时，为了简单，我们假设地址空间不是很大，具体来说，小于物理内存的大小。最后，假设每个地址空间的大小完全一样

## 动态(基于硬件)重定位

- **基址加界限**

- **CPU有两个硬件寄存器**：基址（base）寄存器和界限（bound）寄存器，有时称为限制（limit）寄存器。让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间
- 进程中使用的内存引用都是虚拟地址（`virtual address`），硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址（`physical address`），再发给内存系统。
- **界限寄存器：**界限寄存器提供了访问保护

## 操作系统的问题

1. 在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。
2. 在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些工作，回收它的所有内存，给其他进程或者操作系统使用
3. 在上下文切换时，操作系统也必须执行一些额外的操作。
4. 操作系统必须提供异常处理程序（`exception handler`），或要一些调用的函数

