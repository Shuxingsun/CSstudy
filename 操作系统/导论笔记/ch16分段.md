# 分段

**针对“栈”和“堆”之间的一大块“空闲”空间。**

- **关键问题：**怎样支持大地址空间

怎样支持大地址空间，同时栈和堆之间（可能）有大量空闲空间

## 分段：泛化的基址/界限

- 段只是**地址空间里的一个连续定长**的区域。

- 在典型的地址空间里有 3 个逻辑不同的段：**代码、栈、堆**

- 意义：分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚
  拟地址空间中的未使用部分占用物理内存
- 段的理解：

![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-07-50.png)

**段寄存器：**

| 段   | 基址 | 大小 |
| ---- | ---- | ---- |
| 代码 | 32KB | 2KB  |
| 堆   | 34KB | 2KB  |
| 栈   | 28KB | 2KB  |

- 偏移量+基址寄存器的物理地址得到真正物理地址

- 堆的说明：

来看一个堆中的地址，虚拟地址4200（同样参考图 16.1）。如果用虚拟地址 4200 加上堆的基址（34KB），得到物理地址 39016，这不是正确的地址。我们首先应该先减去堆的偏移量，即该地址指的是这个段中的哪个字节。因为堆从虚拟地址 4K（4096）开始，4200 的偏移量实际上是 4200 减去 4096，即 104，**然后用这个偏移量（104）加上基址寄存器中的物理地址（34KB）**，得到真正的物理地址 34920。

## 引用哪个段

硬件在地址转换时使用段寄存器。**它如何知道段内的偏移量，以及地址引用了哪个段**

- **显式方式**：虚拟地址的开头几位标识

  - 例如3个段，00表示代码，01表示堆。

    ![](https://picture-house.oss-cn-beijing.aliyuncs.com/notes/2022-04-02_11-15-29.png)

  - **偏移量与基址寄存器相加，硬件就得到了最终的物理地址**
  - 但实际只有 3 个段（代码、堆、栈），**因此有一个段的地址空间被浪费。因此有些系统中会将堆和栈当作同一个段**，因此只需要一 位来做标识[LL82]。

- 隐式方式
  - **硬件通过地址产生的方式来确定段**。例如，如果地址由程序计数器产生（即它是指令获取），那么地址在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。

## 栈怎么办

**栈是反向增长**

除了基址和界限外，硬件还需要知道段的增长方向。

**段寄存器：**

| 段   | 基址 | 大小 | 是否反向增长 |
| ---- | ---- | ---- | ------------ |
| 代码 | 32KB | 2KB  | 1            |
| 堆   | 34KB | 2KB  | 1            |
| 栈   | 28KB | 2KB  | 0            |

<u>举例：</u>

假设要访问虚拟地址 15KB，它应该映射到物理地址 27KB。该虚拟地址的二进制形式是：11 1100 0000 0000（十六进制 0x3C00）。硬件利用前两位（11）来指定段，但然后我们要处理偏移量 3KB。为了得到正确的反向偏移，我们必须从 3KB 中减去最大的段地址：在这个例子中，段可以是 4KB，因此正确的偏移量是 3KB 减去 4KB，即−1KB。**只要用这个反向偏移量（−1KB）加上基址（28KB），就得到了正确的物理地址 27KB**。用户可以进行界限检查，确保反向偏移量的绝对值小于段的大小

## 支持共享

**地址空间之间共享（share）某些内存段是有用的**。需要额外的硬件支持——**保护位。**

**保护位**：表示惩处是否能够读写该段或者执行其中代码

| 段   | 基址 | 大小 | 是否反向增长 | 保护    |
| ---- | ---- | ---- | ------------ | ------- |
| 代码 | 32KB | 2KB  | 1            | 读-执行 |
| 堆   | 34KB | 2KB  | 1            | 读-写   |
| 栈   | 28KB | 2KB  | 0            | 读-写   |

## 细粒度与粗粒度的分段

- 粗粒度
  - 针对很少的几个段的系统(代码、栈、堆)
- 细粒度
  - **允许将地址空间划分为大量较小的段**。
  - 需要进一步硬件支持，并且**在内存中保存某种段表**

## 操作系统支持

**操作系统带来的问题：**

- 第一个是老问题：操作系统在上下文切换时应该做什么
  - **各个段寄存器中的内容必须保存和恢复**。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。
- 第二个问题更重要，即管理物理内存的空闲空间
  - **紧凑（compact）物理内存**，重新安排原有的段。
    - **内存紧凑成本很高，因为拷贝段是内存密集型的，一般会占用大量的处理器时间**
  - 更简单的做法是利用**空闲列表管理算法**，试图保留大的内存块用于分配。

**无论算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。**

## 小结

**分段解决了一些问题**

- 帮助我们实现了更高效的虚拟内存。不只是动态重定位，通过避免地址空间的逻辑段之间的大量潜在的内存浪费
- 分段能更好地支持稀疏地址空间

**大小不同的段导致的问题：**

- 外部碎片
- 不足以支持更一般化的稀疏地址空间



